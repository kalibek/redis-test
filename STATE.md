# Предложения по рефакторингу системы

### Описание системы "как есть"

На рисунке ниже представлена текущая последовательность при обработке запроса. Красным указано так называемый "god-object" check aggregate, в котором хранится:
- исходный объект
- состояние обработки запроса из каждой из опрашиваемых систем, 
- ответы каждой из опрашиваемых систем,
- список полученных ошибок

Для корректного обращения к данному объекту используются различные механизы в т.ч. synchronized блоки, reentrantLock, AtomicReferences, что увеличивает сложность поддержки приложения.

Так же за счет использовния этого объекта многими сервисами приложения они становятся тесно связанными, т.е. "знают" об ответственности других сервисов и для каждогов из таких сервисов сложность покрытия юнит-тестами очень высока. Поэтому некоторые ключевые сервисы **не покрыты** юнит тестами

![as-is](./state_as_is.png)

### Описание системы "как будет"

Предлагается:
1. Разбить аггрегатный объект на отдельные объекты (исходный запрос, результат проверки МДМ, результат проверки ФОИВ, Список ошибок и.т.д).
2. Использовать redis(without persistence) и spring-data-redis для обработки результатов
3. Для синхронизации результатов проверки использовать простой stateless spring service

Подход  для п.3 со следующий
- При получении сообщения записать в бд флаги для каждой из асинхронных проверок
- При получении результата каждой из проверок:
    1. обновить соответстующий флаг в бд для текущего запроса
    3. считать состояние всех флагов для данного запроса
    4. если все флаги отмечены, то удалить запрос из базы и если результат удаления положительный, то отправить аггрегированный результат проверки в интеграционный слой

**Данный подход основывается на атомарности операции удаления в бд.** Для redis при удалении одной записи из нескольких потоков, для одного из потоков операция удаления вернет количество удаленных записей т.е. `result != 0`, для остальных соответственно `result == 0`

Так же при использовании redis:

- При необходимости масштабирования приложения БД redis должна быть вынесена в отдельный pod
- БД redis будет использована только как временное хранилище, т.е. без persistence слоя
- Максимальное время жизни объекта в бд == время обработки запроса системой
- Размер бд мал


![as-is](./state_to_be.png)


